4 constituents of design pattern:
1. Name
2. Problem
3. Solution
3. Consequences and trade-offs

Classification of design patterns:
- Purpose: Creational,Structural,Behavioural
- Scope: Class,Object

Implementation inheritance(Class) vs Interface inheritance: Purpose of Implementation inheritance is code sharing/reusability and extensibility,
while Interface inheritance is meant to make sure that objects can be substituted with each other at run time.

Program to an interface, not an implementation.This greatly reduces implementation dependencies between subsystems.
Creational patterns abstract the process of object creation.These patterns give you different ways to associate an interface with its implementation
transparently at instantiation. Creational patterns ensure that your system is written in terms of interfaces, not implementations.

Inheritance versus Composition: Composition allows behaviours ot be composed at run-time as compositions can be done with Interfaces.
With inheritance subclass is bound to parent class's implementation.
Favor object composition over class inheritance.

Creational patterns: Creational design patterns abstract the instantiation process. They enable a software system to be independent of how
its objects are created,composed and represented.A class creational pattern uses inheritance to vary the class that's instantiated,
whereas an object creational pattern will delegate instantiation to another object.
There are two recurring themes in these patterns. First, they all encapsulate knowledge about which concrete classes the system uses.
Second, they hide how instances of these classes are created and put together.

a. Abstract factory pattern: It is a creational pattern which provides an interface for creating families of related or dependent objects without
specifying their concrete classes. Suppose a class depends on several related/dependent objects. One can put code for creating these objects within
the class.
But this approach makes the system inflexible as in future different types of objects may be needed and this would need huge change in class.
With abstract factory, we provide an interface to create the objects. We then can have concrete implementation of this interface which creates
specific type of concrete objects and return abstract/interface type.So client doesn't know which concrete type is created.
When new type of objects is needed, we implement abstract factory interface, and client needs to make a small change and switch to new
implementation.

b. Builder pattern: It is a creational pattern which separates construction of a complex object from its representation.
As a result, same construction process can be used to create different representations.

c. Factory method pattern: It is a creational pattern which provides an interface to create an object, but let subclasses decide which object
to create.

d. Prototype pattern:

e. Singleton pattern: It is a creational pattern and ensures that a class has only one instance, and provides a global point of access to it.

Structural patterns: Structural patterns are concerned with how classes and objects are composed to form larger structures.
Structural class patterns make use of inheritance to compose interfaces/implementations.Structural object patterns describe ways to compose objects
to create new functionality.

a. Adapter pattern: It is a structural pattern which converts interface of a class into another interface that client expects,thus enabling
classes to work with each other which couldn't otherwise due to incompatible interfaces.
Adapter pattern can either make use of inheritance(class scope) or composition(object scope).

b. Bridge pattern: If we have an abstract class which can have several implementations, we use inheritance. Abstract class defines an interface,
and concrete subclasses implements that interface. This creates strong coupling between abstraction and implementation, and hence they can't
evolve independently.
Bridge pattern handles this issue. In this pattern, abstractions and their implementations are placed in different class hierarchies. An interface
is used which acts as a connector/bridge between between these 2 hierarchies. Abstract class contains reference to this bridge interface.

c. Composite design pattern: This design pattern makes it possible for client code to treat a whole tree of parent-child objects as same object.
In a context where objects are arranged in a tree structure with a composite object having leaf objects as well as other composite objects, and
all such objects expected to have same behaviour from client point of view, this pattern makes it possible for client to treat all in same manner.
For eg.,in a drawing application, we may have individual objects like Line,Rectangle,Triangle,Circle etc and composite objects like Picture which
contains individual objects OR other composite objects. Client code needs 'draw' behaviour for all these objects, individual as well as composite.
So we define 'draw' interface, and this constitutes 'Component' interface. We make individual objects,'Leaf', implement this interface.
'Composite' object also implements 'Component' interface, as well as a general interface fro adding/removing leaf/composite objects.
Client code just needs to call 'draw' on top composite object, and call in delegated to all the objects in tree.

d. Decorator design pattern: When we extend a class, subclass inherits features/responsibilities from it. As a result all the objects of subclass
have those aspects. This is desired many times, but sometimes we want some features/responsibilities to be possessed by some individual objects only,
rather than every single object of the class. Decorator pattern helps in achieving this. From client's perspective, it still calls same interface
implemented by the target object.
We define the interface of the target object/class. And we define an abstract Decorator class which implements this interface, so now it has
same interface as target object and client can invoke calls on it transparently.This abstract class also contains the reference to target object.
We implement concrete classes for Decorator,wherin we direct client requests to target object.And while it does so,it also performs the 'decoration'.

Strategy pattern: Encapsulating algorithm in an object is the intent of Strategy pattern.